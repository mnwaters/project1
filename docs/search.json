[
  {
    "objectID": "project1.html",
    "href": "project1.html",
    "title": "Project 1",
    "section": "",
    "text": "Authors: Meerah Waters and Jack Wetzel\n\n\nThis program is designed to create functions to retrieve and analyze data from the US census. The first portion will involve creating a function similar to the get_acs() function from the tidycensus package. It will take inputs from the user to specify the year, variables, and geographic location for which they wish to get data from. The function will then produce a tibble with data adhering to the specifies parameters. Afterwards, there will be additional functions that will allow the user to analyze the previously created tibble. The first is a summary function which will provide counts of categorical variables and basic statistical measures of the numerical variables. The second is a graphing function which takes the summary funciton as an input and produces a box plot based on specified variables.\n\n\n\n\nFirst we need to install the necessary R packages that are used in the generic functions in this exercise.\n\n\nlibrary(tidycensus)\nlibrary(jsonlite)\nlibrary(httr)\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(tidyselect)\nlibrary(ggplot2)\n\n\nThen we need to call the API (this is the default call)\n\n\nacsData &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=region:04\"\n\n\nThen we need to parse the JSON data and put it in tibble format with the helper function\n\n\napiHelper &lt;- function(apiCall) {\n  acsData &lt;- GET(apiCall)\n  parsed &lt;- fromJSON(rawToChar(acsData$content))\n  acsDataTib &lt;- as_tibble(parsed)\n  names(acsDataTib) &lt;- acsDataTib[1,]\n  acsDataTib &lt;- acsDataTib[-1,]\n}\n\n\nNow were going to write a function to query the API that will allow the user to specify certain items. The function allows for the individual to select a year, Numerical Variables, Categorical Variables, and the Geographic area through the inputs of the function. How the function is written, causes only one singular “Geography” selection, while the Numerical and Categorical Variables are able to have multiple responses, as these are only the column headers being selected.\n\n\nacsFunction &lt;- function(year = 2022, \n                        numericalVar = c(\"PWGTP\", \"AGEP\"), \n                        categoricalVar = c(\"SEX\"), \n                        geography = \"state\",\n                        geo_code = \"04\") {\n\n  ## Checking if function input is valid\n  if (year &gt; 2022 | year &lt; 2010) {\n    stop(\"Year must be between 2010 and 2022\")\n  }\n  \n  if (is.null(categoricalVar)) {\n    stop(\"One categorical variable must be returned\")\n  }\n  \n  if (is.null(numericalVar) | all(numericalVar == \"PWGTP\")) {\n    stop(\"One numeric variable other than PWGTP must be returned\")\n  }\n  \n  if (!(geography %in% c(\"state\", \"division\", \"region\"))) {\n    stop(\"Invalid Geography value, must be: (state, division, region)\")\n  }\n  \n  if (is.null(geo_code)) {\n    geo_code &lt;- \"*\"\n  }\n  \n  ## Building the URL\n  variables &lt;- paste(c(numericalVar, categoricalVar), collapse = \",\")\n  \n  ## Ensures PWGTP is always printed\n  if (!(\"PWGTP\") %in% numericalVar) {\n    variables &lt;- paste(\"PWGTP\", variables, sep = \",\")\n  }\n  \n  url &lt;- paste0(\"https://api.census.gov/data/\",\n                year,\n                \"/acs/acs1/pums?get=\",\n                variables,\n                \"&for=\",\n                geography,\n                \":\",\n                geo_code\n                )\n  \n  acsTibble &lt;- apiHelper(apiCall = url)\n  \n  ## Making variables numeric\n  numericalVar &lt;- numericalVar[!(numericalVar %in% c(\"JWAP\", \"JWDP\"))]\n  acsTibble[numericalVar] &lt;- lapply(acsTibble[numericalVar], as.numeric)\n  acsTibble$PWGTP &lt;- as.numeric(acsTibble$PWGTP)\n  \n  ## Making variables factors\n  for (i in 1:length(categoricalVar)) {\n    cat_url &lt;- paste0(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/\",\n                      categoricalVar[i],\n                      \".json\")\n    cat_var &lt;- categoricalVar[i]\n    temp &lt;- GET(cat_url)\n    temp_list &lt;- temp$content |&gt; rawToChar() |&gt; fromJSON()\n    temp_cat &lt;- temp_list$values$item\n    cat_values &lt;- temp_cat[sort(names(temp_cat))]\n    \n    vec &lt;- list()\n    vec &lt;- sapply(acsTibble[cat_var], function(x) cat_values[x])\n    vec &lt;- sapply(vec, function(x) if (is.null(x)) NA else x)\n    vec_num &lt;- unname(unlist(vec))\n    acsTibble[cat_var] &lt;- vec_num\n  }\n  \n  acsTibble &lt;- acsTibble |&gt;\n    mutate(across(where(is.character), as.factor))\n  \n  ## Formatting the time variables as minutes since midnight\n  if (\"JWAP\" %in% colnames(acsTibble)) {\n    temp &lt;- GET(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\")\n    temp_list &lt;- temp$content |&gt; rawToChar() |&gt; fromJSON()\n    temp_JWAP &lt;- temp_list$values$item\n    JWAP_values &lt;- temp_JWAP[sort(names(temp_JWAP))]\n    JWAP_values[1] &lt;- 0  ## Sets the first value to 0 as the loop cannot handle the first value\n    \n    for (i in 2:length(JWAP_values)) {\n      time_strings &lt;- strsplit(JWAP_values[[i]], \" to \")\n      time_1 &lt;- time_strings[[1]][1]\n      time_2 &lt;- time_strings[[1]][2]\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_1)) {\n        time_form_1 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_1)\n      } else {\n        time_form_1 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_1)\n      }\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_2)) {\n        time_form_2 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_2)\n      } else {\n        time_form_2 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_2)\n      }\n      \n      time_24_1 &lt;- format(strptime(time_form_1, \"%I:%M %p\"), format=\"%H:%M\")\n      time_24_2 &lt;- format(strptime(time_form_2, \"%I:%M %p\"), format=\"%H:%M\")\n      \n      time_parts_1 &lt;- strsplit(time_24_1, \":\")[[1]]\n      time_parts_2 &lt;- strsplit(time_24_2, \":\")[[1]]\n      \n      hours_1 &lt;- as.numeric(time_parts_1[1])\n      hours_2 &lt;- as.numeric(time_parts_2[1])\n      minutes_1 &lt;- as.numeric(time_parts_1[2])\n      minutes_2 &lt;- as.numeric(time_parts_2[2])\n      \n      total_time_1 &lt;- hours_1 * 60 + minutes_1\n      total_time_2 &lt;- hours_2 * 60 + minutes_2\n      \n      JWAP_values[i] &lt;- (total_time_1 + total_time_2) / 2\n    }\n    vec &lt;- list()\n    vec &lt;- sapply(acsTibble$JWAP, function(x) JWAP_values[[x]])\n    vec &lt;- sapply(vec, function(x) if (is.null(x)) NA else x)\n    vec_num &lt;- unname(unlist(vec))\n    acsTibble$JWAP &lt;- vec_num\n  }\n  \n  if (\"JWDP\" %in% colnames(acsTibble)) {\n    temp &lt;- GET(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\")\n    temp_list &lt;- temp$content |&gt; rawToChar() |&gt; fromJSON()\n    temp_JWDP &lt;- temp_list$values$item\n    JWDP_values &lt;- temp_JWDP[sort(names(temp_JWDP))]\n    JWDP_values[1] &lt;- 0  ## Sets the first value to 0 as the loop cannot handle the first value\n    \n    for (i in 2:length(JWDP_values)) {\n      time_strings &lt;- strsplit(JWDP_values[[i]], \" to \")\n      time_1 &lt;- time_strings[[1]][1]\n      time_2 &lt;- time_strings[[1]][2]\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_1)) {\n        time_form_1 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_1)\n      } else {\n        time_form_1 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_1)\n      }\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_2)) {\n        time_form_2 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_2)\n      } else {\n        time_form_2 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_2)\n      }\n      \n      time_24_1 &lt;- format(strptime(time_form_1, \"%I:%M %p\"), format=\"%H:%M\")\n      time_24_2 &lt;- format(strptime(time_form_2, \"%I:%M %p\"), format=\"%H:%M\")\n      \n      time_parts_1 &lt;- strsplit(time_24_1, \":\")[[1]]\n      time_parts_2 &lt;- strsplit(time_24_2, \":\")[[1]]\n      \n      hours_1 &lt;- as.numeric(time_parts_1[1])\n      hours_2 &lt;- as.numeric(time_parts_2[1])\n      minutes_1 &lt;- as.numeric(time_parts_1[2])\n      minutes_2 &lt;- as.numeric(time_parts_2[2])\n      \n      total_time_1 &lt;- hours_1 * 60 + minutes_1\n      total_time_2 &lt;- hours_2 * 60 + minutes_2\n      \n      JWDP_values[i] &lt;- (total_time_1 + total_time_2) / 2\n    }\n    vec &lt;- list()\n    vec &lt;- sapply(acsTibble$JWDP, function(x) JWDP_values[[x]])\n    vec &lt;- sapply(vec, function(x) if (is.null(x)) NA else x)\n    vec_num &lt;- unname(unlist(vec))\n    acsTibble$JWDP &lt;- vec_num\n  }\n  \n  ## Removing geography columns from final tibble\n  if (\"state\" %in% colnames(acsTibble)) {\n    acsTibble &lt;- acsTibble |&gt;\n      select(-state)\n  }\n  \n  if (\"division\" %in% colnames(acsTibble)) {\n    acsTibble &lt;- acsTibble |&gt;\n      select(-division)\n  }\n  \n  if (\"region\" %in% colnames(acsTibble)) {\n    acsTibble &lt;- acsTibble |&gt;\n      select(-region)\n  }\n  \n  return(acsTibble)\n}\n\nNow we will test that the acsFunction works as intended. This will be done by giving it different inputs to ensure that all exceptions are handled properly. More tests were done than shown below throughout the coding process, but the ones below show a good picture.\n\n## Test includes values different than function defaults for each input and tests time variable formatting\nacsFunction(year = 2019, categoricalVar = c(\"HISPEED\", \"SCH\"), numericalVar = c(\"JWAP\"), geography = \"region\", geo_code = \"01\")\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\nWarning: The `value` argument of `names&lt;-()` must be a character vector as of tibble\n3.0.0.\n\n\n# A tibble: 566,977 × 4\n   PWGTP  JWAP HISPEED                                        SCH               \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                          &lt;fct&gt;             \n 1    10     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 2    11     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n 3    33     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 4    80     0 N/A (GQ/vacant/no paid access to the internet) Yes, private scho…\n 5    37     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 6    77     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 7    78     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n 8    71     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 9    17     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n10    73     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n# ℹ 566,967 more rows\n\n## Tests function when only some inputs are specified\nacsFunction(numericalVar = c(\"JWMNP\", \"GASP\"), geography = \"division\", geo_code = \"5\")\n\n# A tibble: 676,726 × 4\n   PWGTP JWMNP  GASP SEX  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;\n 1    42     0     3 Male \n 2    32     0     3 Male \n 3    45     0     3 Male \n 4    41     0     3 Male \n 5   119     5     3 Male \n 6     6     0     3 Male \n 7    25     0     3 Male \n 8    59     0     3 Male \n 9    70     0     3 Male \n10     7     0     3 Male \n# ℹ 676,716 more rows\n\n## Tests the checks for valid function inputs\nacsFunction(year = 2008)\n\nError in acsFunction(year = 2008): Year must be between 2010 and 2022\n\nacsFunction(categoricalVar = NULL)\n\nError in acsFunction(categoricalVar = NULL): One categorical variable must be returned\n\nacsFunction(numericalVar = c(\"PWGTP\"))\n\nError in acsFunction(numericalVar = c(\"PWGTP\")): One numeric variable other than PWGTP must be returned\n\nacsFunction(geography = \"city\")\n\nError in acsFunction(geography = \"city\"): Invalid Geography value, must be: (state, division, region)\n\n\n\n## Runs the acsFunction with default inputs\ndefaultTibble &lt;- acsFunction()\n\n\nNow we will build a new function that has similar parameters to the one in step 4 with the exception of allowing the user to specify multiple years. This will call the previous function multiple times and combine multiple tibbles into one. Additionally, it creates a new column titled year.\n\n\nacsMultiYear &lt;- function(years,\n                         numericalVar = c(\"PWGTP\", \"AGEP\"), \n                         categoricalVar = c(\"SEX\"), \n                         geography = \"state\",\n                         geo_code = \"04\") {\n  \n  tibbleList &lt;- list()  ## initializing empty list for the loop\n  \n  for (i in 1:length(years)) {\n    singleYrTib &lt;- acsFunction(years[i], numericalVar, categoricalVar, geography, geo_code)\n    singleYrTib$year &lt;- years[i]  ## creates a new variable based on the year\n    tibbleList[[i]] &lt;- singleYrTib\n  }\n  \n  multYrTib &lt;- bind_rows(tibbleList)  ## combines the list of tibbles into a single tibble\n  \n  return(multYrTib)\n}\n\nWe will now test that the acsMultiYear function works by giving it an input with two different years. Due to high processing time of including multiple years, the head and tail functions were used.\n\nmultYrTest &lt;- acsMultiYear(years = c(2018, 2021))\nhead(multYrTest)  ## year column is 2018\n\n# A tibble: 6 × 4\n  PWGTP  AGEP SEX     year\n  &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt;\n1    10    52 Male    2018\n2    80    23 Female  2018\n3     6    71 Male    2018\n4    92    22 Male    2018\n5     8    93 Male    2018\n6     7    57 Male    2018\n\ntail(multYrTest)  ## year column is 2021\n\n# A tibble: 6 × 4\n  PWGTP  AGEP SEX     year\n  &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt;\n1    65    75 Female  2021\n2   129    19 Female  2021\n3    76    24 Female  2021\n4    76    23 Female  2021\n5    29    85 Male    2021\n6    26    80 Female  2021\n\n\n\n\n\n\nIn this step, we are creating a summary function of our overall tibble, while also adding a new class to the overall data. The summary is dependent on the numerical and categorical variables selected in the acsFunction previously. By default, the function will summarize all variables present in the given tibble, but users can specify the only summarize specific ones.\n\n\nacsSummary &lt;- function(classcensus = defaultTibble,\n                       numericalVar = NULL,\n                       categoricalVar = NULL) {\n    \n    ## Adding the census class to the tibble\n    class(classcensus) &lt;- c(\"census\", class(classcensus))\n    \n    ## Checks if user specifies variables\n    if (!is.null(numericalVar)) {\n      classcensus &lt;- classcensus |&gt;\n        select(where(is.factor), PWGTP, all_of(numericalVar))\n    }\n    \n    if (!is.null(categoricalVar)) {\n      classcensus &lt;- classcensus |&gt;\n        select(where(is.numeric), all_of(categoricalVar))\n    }\n    \n    ## Creates a tibble with counts for categorical variables\n    acsSummaryCat &lt;- classcensus |&gt;\n      pivot_longer(where(is.factor), names_to = \"column_name\", values_to = \"var_count\") |&gt;\n      count(PWGTP, column_name, var_count) |&gt;\n      pivot_wider(names_from = c(column_name, var_count), values_from = n, values_fill = 0)\n    \n    ## Creates a tibble with weighted mean & sd of numerical variables\n    acsSummaryNum &lt;- classcensus |&gt;\n      group_by(PWGTP) |&gt;\n      mutate(across(where(is.numeric), \n                    list(mean = mean, sd = sd), \n                    .names = \"{.col}_{.fn}\")) |&gt;\n      arrange(PWGTP) |&gt;\n      select(PWGTP, ends_with(\"mean\"), \n             ends_with(\"sd\")) |&gt;\n      distinct()\n    \n    ## Combines the numerical and categorical tibbles\n    acsTibbleSummary &lt;- full_join(acsSummaryCat, acsSummaryNum)\n      \n    return(acsTibbleSummary)\n}\n\nNow we will test that the acsSummary function works as intended. This test makes sure that there are columns for the categorical variable counts along with a column for the mean & sd of numerical variables. It also tests that users are able to specify to summarize only specific variables from the original tibble.\n\ntest_tibble &lt;- acsFunction(2021, categoricalVar = c(\"HHL\", \"FER\"), numericalVar = c(\"JWAP\", \"GASP\"))\ntestsummary &lt;- acsSummary(classcensus = test_tibble, numericalVar = c(\"JWAP\"), categoricalVar = (\"HHL\"))\n\nJoining with `by = join_by(PWGTP)`\n\ntestsummary\n\n# A tibble: 608 × 9\n   PWGTP `HHL_N/A (GQ/vacant)` `HHL_Other Language` `HHL_English Only`\n   &lt;dbl&gt;                 &lt;int&gt;                &lt;int&gt;              &lt;int&gt;\n 1     1                    34                    0                  0\n 2     2                    40                    1                  0\n 3     3                    36                    1                  0\n 4     4                    68                    2                  0\n 5     5                    89                    2                  3\n 6     6                    99                    6                  6\n 7     7                    74                   15                  5\n 8     8                    62                   16                 13\n 9     9                    49                   14                 17\n10    10                    61                   23                 21\n# ℹ 598 more rows\n# ℹ 5 more variables: HHL_Spanish &lt;int&gt;,\n#   `HHL_Asian and Pacific Island languages` &lt;int&gt;,\n#   `HHL_Other Indo-European languages` &lt;int&gt;, JWAP_mean &lt;dbl&gt;, JWAP_sd &lt;dbl&gt;\n\n\n\nAfter creating our summary of our selected data, we are now able to plot the data in a digestible graph!\n\n\nacsPlot &lt;- function(dataset = testsummary,\n                    numericalVar = \"mean_GASP\",\n                    categoricalVar = \"mean_HHL\") {\n \n  ggplot(dataset,\n         aes(x = get(categoricalVar), y = get(numericalVar), weight = PWGTP)) +\n    geom_boxplot()\n}\n\n\nacsPlot(testsummary, \"JWAP_sd\", \"HHL_Spanish\")\n\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n\n\nWarning: Removed 81 rows containing non-finite outside the scale range\n(`stat_boxplot()`)."
  },
  {
    "objectID": "project1.html#introduction",
    "href": "project1.html#introduction",
    "title": "Project 1",
    "section": "",
    "text": "This program is designed to create functions to retrieve and analyze data from the US census. The first portion will involve creating a function similar to the get_acs() function from the tidycensus package. It will take inputs from the user to specify the year, variables, and geographic location for which they wish to get data from. The function will then produce a tibble with data adhering to the specifies parameters. Afterwards, there will be additional functions that will allow the user to analyze the previously created tibble. The first is a summary function which will provide counts of categorical variables and basic statistical measures of the numerical variables. The second is a graphing function which takes the summary funciton as an input and produces a box plot based on specified variables."
  },
  {
    "objectID": "project1.html#task-1-data-processing",
    "href": "project1.html#task-1-data-processing",
    "title": "Project 1",
    "section": "",
    "text": "First we need to install the necessary R packages that are used in the generic functions in this exercise.\n\n\nlibrary(tidycensus)\nlibrary(jsonlite)\nlibrary(httr)\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(lubridate)\nlibrary(tidyselect)\nlibrary(ggplot2)\n\n\nThen we need to call the API (this is the default call)\n\n\nacsData &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=PWGTP,AGEP,SEX&for=region:04\"\n\n\nThen we need to parse the JSON data and put it in tibble format with the helper function\n\n\napiHelper &lt;- function(apiCall) {\n  acsData &lt;- GET(apiCall)\n  parsed &lt;- fromJSON(rawToChar(acsData$content))\n  acsDataTib &lt;- as_tibble(parsed)\n  names(acsDataTib) &lt;- acsDataTib[1,]\n  acsDataTib &lt;- acsDataTib[-1,]\n}\n\n\nNow were going to write a function to query the API that will allow the user to specify certain items. The function allows for the individual to select a year, Numerical Variables, Categorical Variables, and the Geographic area through the inputs of the function. How the function is written, causes only one singular “Geography” selection, while the Numerical and Categorical Variables are able to have multiple responses, as these are only the column headers being selected.\n\n\nacsFunction &lt;- function(year = 2022, \n                        numericalVar = c(\"PWGTP\", \"AGEP\"), \n                        categoricalVar = c(\"SEX\"), \n                        geography = \"state\",\n                        geo_code = \"04\") {\n\n  ## Checking if function input is valid\n  if (year &gt; 2022 | year &lt; 2010) {\n    stop(\"Year must be between 2010 and 2022\")\n  }\n  \n  if (is.null(categoricalVar)) {\n    stop(\"One categorical variable must be returned\")\n  }\n  \n  if (is.null(numericalVar) | all(numericalVar == \"PWGTP\")) {\n    stop(\"One numeric variable other than PWGTP must be returned\")\n  }\n  \n  if (!(geography %in% c(\"state\", \"division\", \"region\"))) {\n    stop(\"Invalid Geography value, must be: (state, division, region)\")\n  }\n  \n  if (is.null(geo_code)) {\n    geo_code &lt;- \"*\"\n  }\n  \n  ## Building the URL\n  variables &lt;- paste(c(numericalVar, categoricalVar), collapse = \",\")\n  \n  ## Ensures PWGTP is always printed\n  if (!(\"PWGTP\") %in% numericalVar) {\n    variables &lt;- paste(\"PWGTP\", variables, sep = \",\")\n  }\n  \n  url &lt;- paste0(\"https://api.census.gov/data/\",\n                year,\n                \"/acs/acs1/pums?get=\",\n                variables,\n                \"&for=\",\n                geography,\n                \":\",\n                geo_code\n                )\n  \n  acsTibble &lt;- apiHelper(apiCall = url)\n  \n  ## Making variables numeric\n  numericalVar &lt;- numericalVar[!(numericalVar %in% c(\"JWAP\", \"JWDP\"))]\n  acsTibble[numericalVar] &lt;- lapply(acsTibble[numericalVar], as.numeric)\n  acsTibble$PWGTP &lt;- as.numeric(acsTibble$PWGTP)\n  \n  ## Making variables factors\n  for (i in 1:length(categoricalVar)) {\n    cat_url &lt;- paste0(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/\",\n                      categoricalVar[i],\n                      \".json\")\n    cat_var &lt;- categoricalVar[i]\n    temp &lt;- GET(cat_url)\n    temp_list &lt;- temp$content |&gt; rawToChar() |&gt; fromJSON()\n    temp_cat &lt;- temp_list$values$item\n    cat_values &lt;- temp_cat[sort(names(temp_cat))]\n    \n    vec &lt;- list()\n    vec &lt;- sapply(acsTibble[cat_var], function(x) cat_values[x])\n    vec &lt;- sapply(vec, function(x) if (is.null(x)) NA else x)\n    vec_num &lt;- unname(unlist(vec))\n    acsTibble[cat_var] &lt;- vec_num\n  }\n  \n  acsTibble &lt;- acsTibble |&gt;\n    mutate(across(where(is.character), as.factor))\n  \n  ## Formatting the time variables as minutes since midnight\n  if (\"JWAP\" %in% colnames(acsTibble)) {\n    temp &lt;- GET(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\")\n    temp_list &lt;- temp$content |&gt; rawToChar() |&gt; fromJSON()\n    temp_JWAP &lt;- temp_list$values$item\n    JWAP_values &lt;- temp_JWAP[sort(names(temp_JWAP))]\n    JWAP_values[1] &lt;- 0  ## Sets the first value to 0 as the loop cannot handle the first value\n    \n    for (i in 2:length(JWAP_values)) {\n      time_strings &lt;- strsplit(JWAP_values[[i]], \" to \")\n      time_1 &lt;- time_strings[[1]][1]\n      time_2 &lt;- time_strings[[1]][2]\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_1)) {\n        time_form_1 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_1)\n      } else {\n        time_form_1 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_1)\n      }\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_2)) {\n        time_form_2 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_2)\n      } else {\n        time_form_2 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_2)\n      }\n      \n      time_24_1 &lt;- format(strptime(time_form_1, \"%I:%M %p\"), format=\"%H:%M\")\n      time_24_2 &lt;- format(strptime(time_form_2, \"%I:%M %p\"), format=\"%H:%M\")\n      \n      time_parts_1 &lt;- strsplit(time_24_1, \":\")[[1]]\n      time_parts_2 &lt;- strsplit(time_24_2, \":\")[[1]]\n      \n      hours_1 &lt;- as.numeric(time_parts_1[1])\n      hours_2 &lt;- as.numeric(time_parts_2[1])\n      minutes_1 &lt;- as.numeric(time_parts_1[2])\n      minutes_2 &lt;- as.numeric(time_parts_2[2])\n      \n      total_time_1 &lt;- hours_1 * 60 + minutes_1\n      total_time_2 &lt;- hours_2 * 60 + minutes_2\n      \n      JWAP_values[i] &lt;- (total_time_1 + total_time_2) / 2\n    }\n    vec &lt;- list()\n    vec &lt;- sapply(acsTibble$JWAP, function(x) JWAP_values[[x]])\n    vec &lt;- sapply(vec, function(x) if (is.null(x)) NA else x)\n    vec_num &lt;- unname(unlist(vec))\n    acsTibble$JWAP &lt;- vec_num\n  }\n  \n  if (\"JWDP\" %in% colnames(acsTibble)) {\n    temp &lt;- GET(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\")\n    temp_list &lt;- temp$content |&gt; rawToChar() |&gt; fromJSON()\n    temp_JWDP &lt;- temp_list$values$item\n    JWDP_values &lt;- temp_JWDP[sort(names(temp_JWDP))]\n    JWDP_values[1] &lt;- 0  ## Sets the first value to 0 as the loop cannot handle the first value\n    \n    for (i in 2:length(JWDP_values)) {\n      time_strings &lt;- strsplit(JWDP_values[[i]], \" to \")\n      time_1 &lt;- time_strings[[1]][1]\n      time_2 &lt;- time_strings[[1]][2]\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_1)) {\n        time_form_1 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_1)\n      } else {\n        time_form_1 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_1)\n      }\n      \n      if (grepl(\"a\\\\.m\\\\.\", time_2)) {\n        time_form_2 &lt;- gsub(\"a\\\\.m\\\\.\", \"AM\", time_2)\n      } else {\n        time_form_2 &lt;- gsub(\"p\\\\.m\\\\.\", \"PM\", time_2)\n      }\n      \n      time_24_1 &lt;- format(strptime(time_form_1, \"%I:%M %p\"), format=\"%H:%M\")\n      time_24_2 &lt;- format(strptime(time_form_2, \"%I:%M %p\"), format=\"%H:%M\")\n      \n      time_parts_1 &lt;- strsplit(time_24_1, \":\")[[1]]\n      time_parts_2 &lt;- strsplit(time_24_2, \":\")[[1]]\n      \n      hours_1 &lt;- as.numeric(time_parts_1[1])\n      hours_2 &lt;- as.numeric(time_parts_2[1])\n      minutes_1 &lt;- as.numeric(time_parts_1[2])\n      minutes_2 &lt;- as.numeric(time_parts_2[2])\n      \n      total_time_1 &lt;- hours_1 * 60 + minutes_1\n      total_time_2 &lt;- hours_2 * 60 + minutes_2\n      \n      JWDP_values[i] &lt;- (total_time_1 + total_time_2) / 2\n    }\n    vec &lt;- list()\n    vec &lt;- sapply(acsTibble$JWDP, function(x) JWDP_values[[x]])\n    vec &lt;- sapply(vec, function(x) if (is.null(x)) NA else x)\n    vec_num &lt;- unname(unlist(vec))\n    acsTibble$JWDP &lt;- vec_num\n  }\n  \n  ## Removing geography columns from final tibble\n  if (\"state\" %in% colnames(acsTibble)) {\n    acsTibble &lt;- acsTibble |&gt;\n      select(-state)\n  }\n  \n  if (\"division\" %in% colnames(acsTibble)) {\n    acsTibble &lt;- acsTibble |&gt;\n      select(-division)\n  }\n  \n  if (\"region\" %in% colnames(acsTibble)) {\n    acsTibble &lt;- acsTibble |&gt;\n      select(-region)\n  }\n  \n  return(acsTibble)\n}\n\nNow we will test that the acsFunction works as intended. This will be done by giving it different inputs to ensure that all exceptions are handled properly. More tests were done than shown below throughout the coding process, but the ones below show a good picture.\n\n## Test includes values different than function defaults for each input and tests time variable formatting\nacsFunction(year = 2019, categoricalVar = c(\"HISPEED\", \"SCH\"), numericalVar = c(\"JWAP\"), geography = \"region\", geo_code = \"01\")\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\nWarning: The `value` argument of `names&lt;-()` must be a character vector as of tibble\n3.0.0.\n\n\n# A tibble: 566,977 × 4\n   PWGTP  JWAP HISPEED                                        SCH               \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                          &lt;fct&gt;             \n 1    10     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 2    11     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n 3    33     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 4    80     0 N/A (GQ/vacant/no paid access to the internet) Yes, private scho…\n 5    37     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 6    77     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 7    78     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n 8    71     0 N/A (GQ/vacant/no paid access to the internet) No, has not atten…\n 9    17     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n10    73     0 N/A (GQ/vacant/no paid access to the internet) Yes, public schoo…\n# ℹ 566,967 more rows\n\n## Tests function when only some inputs are specified\nacsFunction(numericalVar = c(\"JWMNP\", \"GASP\"), geography = \"division\", geo_code = \"5\")\n\n# A tibble: 676,726 × 4\n   PWGTP JWMNP  GASP SEX  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;\n 1    42     0     3 Male \n 2    32     0     3 Male \n 3    45     0     3 Male \n 4    41     0     3 Male \n 5   119     5     3 Male \n 6     6     0     3 Male \n 7    25     0     3 Male \n 8    59     0     3 Male \n 9    70     0     3 Male \n10     7     0     3 Male \n# ℹ 676,716 more rows\n\n## Tests the checks for valid function inputs\nacsFunction(year = 2008)\n\nError in acsFunction(year = 2008): Year must be between 2010 and 2022\n\nacsFunction(categoricalVar = NULL)\n\nError in acsFunction(categoricalVar = NULL): One categorical variable must be returned\n\nacsFunction(numericalVar = c(\"PWGTP\"))\n\nError in acsFunction(numericalVar = c(\"PWGTP\")): One numeric variable other than PWGTP must be returned\n\nacsFunction(geography = \"city\")\n\nError in acsFunction(geography = \"city\"): Invalid Geography value, must be: (state, division, region)\n\n\n\n## Runs the acsFunction with default inputs\ndefaultTibble &lt;- acsFunction()\n\n\nNow we will build a new function that has similar parameters to the one in step 4 with the exception of allowing the user to specify multiple years. This will call the previous function multiple times and combine multiple tibbles into one. Additionally, it creates a new column titled year.\n\n\nacsMultiYear &lt;- function(years,\n                         numericalVar = c(\"PWGTP\", \"AGEP\"), \n                         categoricalVar = c(\"SEX\"), \n                         geography = \"state\",\n                         geo_code = \"04\") {\n  \n  tibbleList &lt;- list()  ## initializing empty list for the loop\n  \n  for (i in 1:length(years)) {\n    singleYrTib &lt;- acsFunction(years[i], numericalVar, categoricalVar, geography, geo_code)\n    singleYrTib$year &lt;- years[i]  ## creates a new variable based on the year\n    tibbleList[[i]] &lt;- singleYrTib\n  }\n  \n  multYrTib &lt;- bind_rows(tibbleList)  ## combines the list of tibbles into a single tibble\n  \n  return(multYrTib)\n}\n\nWe will now test that the acsMultiYear function works by giving it an input with two different years. Due to high processing time of including multiple years, the head and tail functions were used.\n\nmultYrTest &lt;- acsMultiYear(years = c(2018, 2021))\nhead(multYrTest)  ## year column is 2018\n\n# A tibble: 6 × 4\n  PWGTP  AGEP SEX     year\n  &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt;\n1    10    52 Male    2018\n2    80    23 Female  2018\n3     6    71 Male    2018\n4    92    22 Male    2018\n5     8    93 Male    2018\n6     7    57 Male    2018\n\ntail(multYrTest)  ## year column is 2021\n\n# A tibble: 6 × 4\n  PWGTP  AGEP SEX     year\n  &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt;\n1    65    75 Female  2021\n2   129    19 Female  2021\n3    76    24 Female  2021\n4    76    23 Female  2021\n5    29    85 Male    2021\n6    26    80 Female  2021"
  },
  {
    "objectID": "project1.html#task-2-data-summary",
    "href": "project1.html#task-2-data-summary",
    "title": "Project 1",
    "section": "",
    "text": "In this step, we are creating a summary function of our overall tibble, while also adding a new class to the overall data. The summary is dependent on the numerical and categorical variables selected in the acsFunction previously. By default, the function will summarize all variables present in the given tibble, but users can specify the only summarize specific ones.\n\n\nacsSummary &lt;- function(classcensus = defaultTibble,\n                       numericalVar = NULL,\n                       categoricalVar = NULL) {\n    \n    ## Adding the census class to the tibble\n    class(classcensus) &lt;- c(\"census\", class(classcensus))\n    \n    ## Checks if user specifies variables\n    if (!is.null(numericalVar)) {\n      classcensus &lt;- classcensus |&gt;\n        select(where(is.factor), PWGTP, all_of(numericalVar))\n    }\n    \n    if (!is.null(categoricalVar)) {\n      classcensus &lt;- classcensus |&gt;\n        select(where(is.numeric), all_of(categoricalVar))\n    }\n    \n    ## Creates a tibble with counts for categorical variables\n    acsSummaryCat &lt;- classcensus |&gt;\n      pivot_longer(where(is.factor), names_to = \"column_name\", values_to = \"var_count\") |&gt;\n      count(PWGTP, column_name, var_count) |&gt;\n      pivot_wider(names_from = c(column_name, var_count), values_from = n, values_fill = 0)\n    \n    ## Creates a tibble with weighted mean & sd of numerical variables\n    acsSummaryNum &lt;- classcensus |&gt;\n      group_by(PWGTP) |&gt;\n      mutate(across(where(is.numeric), \n                    list(mean = mean, sd = sd), \n                    .names = \"{.col}_{.fn}\")) |&gt;\n      arrange(PWGTP) |&gt;\n      select(PWGTP, ends_with(\"mean\"), \n             ends_with(\"sd\")) |&gt;\n      distinct()\n    \n    ## Combines the numerical and categorical tibbles\n    acsTibbleSummary &lt;- full_join(acsSummaryCat, acsSummaryNum)\n      \n    return(acsTibbleSummary)\n}\n\nNow we will test that the acsSummary function works as intended. This test makes sure that there are columns for the categorical variable counts along with a column for the mean & sd of numerical variables. It also tests that users are able to specify to summarize only specific variables from the original tibble.\n\ntest_tibble &lt;- acsFunction(2021, categoricalVar = c(\"HHL\", \"FER\"), numericalVar = c(\"JWAP\", \"GASP\"))\ntestsummary &lt;- acsSummary(classcensus = test_tibble, numericalVar = c(\"JWAP\"), categoricalVar = (\"HHL\"))\n\nJoining with `by = join_by(PWGTP)`\n\ntestsummary\n\n# A tibble: 608 × 9\n   PWGTP `HHL_N/A (GQ/vacant)` `HHL_Other Language` `HHL_English Only`\n   &lt;dbl&gt;                 &lt;int&gt;                &lt;int&gt;              &lt;int&gt;\n 1     1                    34                    0                  0\n 2     2                    40                    1                  0\n 3     3                    36                    1                  0\n 4     4                    68                    2                  0\n 5     5                    89                    2                  3\n 6     6                    99                    6                  6\n 7     7                    74                   15                  5\n 8     8                    62                   16                 13\n 9     9                    49                   14                 17\n10    10                    61                   23                 21\n# ℹ 598 more rows\n# ℹ 5 more variables: HHL_Spanish &lt;int&gt;,\n#   `HHL_Asian and Pacific Island languages` &lt;int&gt;,\n#   `HHL_Other Indo-European languages` &lt;int&gt;, JWAP_mean &lt;dbl&gt;, JWAP_sd &lt;dbl&gt;\n\n\n\nAfter creating our summary of our selected data, we are now able to plot the data in a digestible graph!\n\n\nacsPlot &lt;- function(dataset = testsummary,\n                    numericalVar = \"mean_GASP\",\n                    categoricalVar = \"mean_HHL\") {\n \n  ggplot(dataset,\n         aes(x = get(categoricalVar), y = get(numericalVar), weight = PWGTP)) +\n    geom_boxplot()\n}\n\n\nacsPlot(testsummary, \"JWAP_sd\", \"HHL_Spanish\")\n\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n\n\nWarning: Removed 81 rows containing non-finite outside the scale range\n(`stat_boxplot()`)."
  }
]